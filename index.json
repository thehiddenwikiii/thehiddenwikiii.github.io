[{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/ascis/","section":"Tags","summary":"","title":"Ascis","type":"tags"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/blog/","section":"Blogs","summary":"","title":"Blogs","type":"blog"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/categories/ctf/","section":"Categories","summary":"","title":"CTF","type":"categories"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/","section":"Home","summary":"","title":"Home","type":"page"},{"content":" 1. Sơ đồ hoạt động # Đề bài cung cấp 03 tập tin: Initializer.exe, config.ini, capture.pcapng. Dưới đây là sơ đồ hoạt động của chương trình:\nHình 1. Sơ đồ hoạt động của chương trình\nBước (01): Luồng hoạt động bắt đầu từ tập tin Initializer.exe. Khi thực thi, tập tin EXE giải mã và kích chạy tập tin laskdqu.txt (1). Tập tin TXT trên được lưu vào đường dẫn thư mục %TEMP%. Bước (02), (03): Tập tin laskdqu.txt khi thực thi, có chức năng giải mã tập tin config.ini và gửi dữ liệu giải mã về tập tin Initializer.exe. Bước (04): Tập tin Initializer.exe kích chạy ứng dụng MS StickyNotes, đóng vai trò là tập tin mồi nhử. Bước (05), (06): Tập tin Initializer.exe tiến hành giải nén, nhả và kích chạy tập tin laskdqu.txt (2). Tập tin này có chức năng chụp màn hình và gửi về máy chủ C\u0026amp;C. 2. Phân tích tập tin Initializer.exe (Phần 01) # 2.1 API Hashing # Chương trình sử dụng hàm mw_resolve_api_from_hash để phân giải địa chỉ của các API và địa chỉ của các module. Dưới đây là 02 thuật toán hash được sử dụng gồm có:\nThuật toán hash dành cho module v16 = 0; v17 = 1; if ( v15 \u0026gt; 0 ) { length_dll_name = v15; do { v19 = *base_dll_name++; v17 = (v19 + v17) % 0xFFF1; v16 = (v17 + v16) % 0xFFF1; --length_dll_name; } while ( length_dll_name ); } v20 = 0; v21 = 0; do { v22 = 0x53D25A33u \u0026gt;\u0026gt; (v21 + 0x18); v21 -= 8; v20 += 8; v17 = (v22 + v17) % 0xFFF1; v16 = (v17 + v16) % 0xFFF1; } while ( v20 \u0026lt; 0x20 ); if ( (v17 | (v16 \u0026lt;\u0026lt; 0x10)) == hash_module_compare ) { // Trả về địa chỉ của module tương ứng với hash được chỉ định. } Thuật toán hash dành cho API function_name_va = module_base + *address_of_names_rva; LODWORD(function_name) = *function_name_va; for ( k = 0x10; function_name; k = (k + v34) ^ (v35 + v33) ) { ++function_name_va; v33 = ((function_name + k) \u0026gt;\u0026gt; 1) \u0026amp; 0x7FFFFF80; v34 = function_name + ((function_name + k) \u0026gt;\u0026gt; 8); v35 = (function_name + k) \u0026lt;\u0026lt; 7; LODWORD(function_name) = *function_name_va; } if ( ((k + (k ^ 9)) ^ ((k + (k ^ 9)) \u0026lt;\u0026lt; 0xD)) + (((k + (k ^ 9)) \u0026amp; 0x7FFC0 ^ ((k + (k ^ 9u)) \u0026gt;\u0026gt; 0xD)) \u0026gt;\u0026gt; 6) == hash_function_compare ) { return (module_base + address_of_functions_rva[(*address_of_name_ordinals_rva + module_base)]); } 2.2 Chức năng của tập tin Initializer.exe (Phần 01) # Đầu tiên, tập tin Initializer.exe khởi tạo 01 Salt thông qua 07 hàm check. Trong đó, Salt gồm 08 ký tự, bao gồm ký tự 0, 1 và phần tử thứ 07 được xác định là 1. Các hàm check này nằm trong hàm __scrt_common_main_seh(void) và được thực thi trước hàm Main. Dưới đây là ảnh chụp và chức năng của các hàm check:\nHình 2. Danh sách các hàm check được dùng để khởi tạo Salt\nHàm mw_check_elevation_status_in_process: kiểm tra tiến trình hiện tại có quyền administrator hay không. Hàm mw_check_total_disk_free_space: kiểm tra tổng dung lượng ổ đĩa C có lớn hơn 100GB hay không. Hàm mw_get_return_value: trả về giá trị 1. Tuy nhiên, nếu nhìn flow trên Assembly thì nó có 1 đoạn JMP luôn bỏ qua đoạn asm trả về giá trị 0. Hàm mw_check_unix_time_stamp: kiểm tra timestamp hiện tại trên máy có nhỏ hơn hoặc bằng giá trị 1747130569 hay không. Trong đó, giá trị 1747130569 khi chuyển sang ngày giờ sẽ là: Tuesday, 13 May 2025 10:02:49 theo múi giờ GMT. Nếu chuyển sang múi giờ GMT +7 sẽ là: Thứ 03, ngày 13/05/2025, lúc 17:02:49. Hàm mw_detect_VM: đầu tiên, chương trình kiểm tra sự tồn tại của đường dẫn C:\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\StartUp\\\\agent.pyw, sau đó kiểm tra môi trường thực thi trên máy tính có dùng máy ảo VirtualBox hoặc VMWare hay không. Hàm mw_catch_debug_cmd_expection: kiểm tra chương trình có sử dụng trình debugger hay không. Nếu có, chương trình sẽ trigger hàm mw_set_value_to_1 để ghi giá trị 1 vào mảng Salt. Hàm mw_check_OS_version_is_win11_22H2: kiểm tra phiên bản hệ điều hành có phải là Windows 11 22H2 hay không. Sau khi khởi tạo Salt thành công, chương trình gửi Salt vào 01 vùng nhớ chia sẻ (named shared memory) đã được tạo trước đó. Cuối cùng, tập tin Initializer.exe giải mã dữ liệu và lưu với tên laskdqu.txt tại đường dẵn thư mục %TEMP%. Tôi đổi tên tập tin thành laskdqu_txt_stage2.bin để phân biệt với các tập tin khác trong quá trình phân tích.\nHình 3. Thuật toán tuỳ chỉnh được dùng để giải mã dữ liệu và lưu với tên laskdqu.txt (1)\n3. Phân tích tập tin laskdqu_txt_stage2.bin # 3.1 API Hashing # Thuật toán hash mà chương trình sử dụng kết hợp giữa thuật toán Rotate Left 32-bit tuỳ chỉnh với thuật toán XOR. Dưới đây là đoạn mã giả biểu diễn thuật toán trên:\noutput_hash = 0; do { idx_func_name = *function_name++; output_hash = idx_func_name ^ __ROL4__(output_hash, 6); } while ( idx_func_name \u0026gt;= 1 ); Trong đó, các hash được lấy từ địa chỉ 0x400108 cho đến 0x400178. Dưới đây là hình chụp của các hash được sử dụng để resolve ra API.\nHình 4. Danh sách các hash được sử dụng để phân giải ra API tương ứng\n3.2 Chức năng của tập tin laskdqu_txt_stage2.bin # Chức năng chính của tập tin này đó là giải mã tập tin config.ini, sau đó gửi dữ liệu giải mã về tập tin Initializer.exe thông qua vùng nhớ chia sẻ (named shared memory). Cụ thể, chương trình sử dụng thuật toán AES-ECB từ thư viện BCrypt để giải mã, trong đó, aes_key được khởi tạo bằng thuật toán SHA256-HMAC với chuỗi đầu vào là In1t_Sh33sh, Salt nhận được từ tập tin Initializer.exe.\nHình 5. Đoạn mã có chức năng giải mã dữ liệu\nHình 6. Đoạn mã có chức năng gửi dữ liệu giải mã được về tập tin Initializer.exe\n4. Phân tích tập tin Initializer.exe (Phần 02) # 4.1 Chức năng của tập tin Initializer.exe (Phần 02) # Sau khi nhận được dữ liệu từ tập tin laskdqu_txt_stage2.bin, chương trình tiến hành giải nén dữ liệu bằng thuật toán LZNT1. Sau đó, chương trình kích chạy tiến trình MS StickyNotes thông qua câu lệnh open shell:appsfolder\\\\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe!App. Tiến trình này đóng vai trò là mồi nhử, dùng để đánh lạc hướng người dùng đang mở ứng dụng StickyNotes. Đồng thời, chương trình ghi xuống tập tin laskdqu_txt (2) vào đường dẫn thư mục %TEMP%, với giá trị là dữ liệu giải nén trước đó và kích thước đầu ra là 0x10000 bytes. Cuối cùng, tập tin Initializer.exe kích chạy tập tin laskdqu_txt (2)thông qua API CreateProcessA.\nHình 7. Đoạn mã có chức năng giải nén dữ liệu\nHình 8. Đoạn mã có chức năng kích chạy tiến trình StickyNotes\n4.2. Giải mã dữ liệu # Như đã đề cập ở mục Chức năng của tập tin Initializer.exe (Phần 01) và Chức năng của tập tin Initializer.exe (Phần 02), mình phải tìm chính xác được Salt, từ đó mới có thể giải nén dữ liệu thành công.\nMình đã biết Salt được khởi tạo từ 07 hàm check và mình cũng biết ở vị trí thứ 07 có giá trị là 1, từ đó giải mã ra được tập tin tiếp theo. Tuy nhiên, nếu chỉ tập trung phân tích 07 hàm trên để xác định Salt, nó sẽ làm mất thời gian phân tích. Vì vậy, mình đã brute-force 07 phần tử còn lại trong mảng Salt bằng cách tận dụng mã giả của chương trình để giải quyết, xét thấy viết lại chương trình bằng C/C++ sẽ giúp mình hiểu rõ hơn cách hoạt động của chương trình, cũng như tránh sai sót trong quá trình brute-force.\nĐây là script để mình tìm giá trị Salt cũng như lưu tập tin sau khi tìm đúng giá trị: Brute-force stage2. Từ đó mình đã tìm được giá trị Salt là: 10111011. Tập tin giải mã thành công mình đổi tên thành laskdqu_txt_stage3.bin.\n5. Phân tích tập tin laskdqu_txt_stage3.bin # 5.1 Junk code # Khi phân tích bằng IDA, mình nhận thấy những hàm quan trọng của chương trình đều được chèn các \u0026ldquo;mã rác\u0026rdquo; (Junk code), nhằm cản trở quá trình phân tích tĩnh. Để giải quyết chúng, mình đã xác định các bytes \u0026ldquo;rác\u0026rdquo;, sau đó dùng hàm idc.find_binary trong IDA Python để tìm kiếm tất cả các pattern nằm trong khoảng địa chỉ được chỉ định. Sau đó dùng hàm ida_bytes.patch_byte để NOP các bytes rác. Dưới đây là ảnh chụp so sánh 02 đoạn mã trước và sau khi xử lý mã rác:\nHình 9. Một phần mã giả ban đầu bị chèn mã rác\nHình 10. Mã giả sau khi xử lý các đoạn mã rác\nĐây là script xử lý mã rác: kill_junk_code.py\n5.2 Chức năng của tập tin laskdqu_txt_stage3.bin # Chức năng chính của tập tin laskdqu_txt_stage3.bin đó là: chụp ảnh màn hình máy tính, sau đó lưu tập tin ảnh vào đường dẫn thư mục %TEMP%. Tiếp đến, tập tin trên đọc nội dung tập tin ảnh để tiến hành mã hoá chúng. Thuật toán mà tập tin laskdqu_txt_stage3.bin sử dụng là RC4 với arc4_key là GetProcAd\\x00\\x00\\x00, sau đó encode dữ liệu bằng thuật toán Base64. Điều đáng chú ý đó là, hàm SystemFunction032 được sử dụng là một hàm undocumented có chức năng thực hiện thuật toán RC4.\nHình 11. Đoạn mã có chức năng chụp màn hình\nHình 12. Đoạn mã có chức năng lưu tập tin ảnh vào đường dẫn thư mục %TEMP%\nHình 13. Đoạn mã có chức năng mã hoá dữ liệu ảnh thông qua hàm SystemFunction032\nHình 14. Đoạn mã có chức năng encode dữ liệu bằng thuật toán Base64\nDữ liệu sau khi mã hoá sẽ được gửi về máy chủ C\u0026amp;C. Qua phân tích, mình thu được thông tin cấu hình như sau:\nIP: 192.168.160.135 Port: 80 Http method: POST 6. Lời giải # Dựa vào chức năng đã đề cập ở mục Chức năng của tập tin laskdqu_txt_stage3.bin, mình có thể xác định được flag sẽ nằm trong tập tin capture.pcapng. Trước khi tiến hành giải mã tập tin ảnh, mình cần tổng hợp lại một số thông tin quan trọng bao gồm:\nThuật toán sử dụng: RC4 và Base64 Khoá được sử dụng trong thuật toán RC4: GetProcAd\\x00\\x00\\x00 IP: 192.168.160.135 Port: 80 Http method: POST Việc mình cần tìm lúc này là chuỗi base64 được ghi lại khi gửi về máy chủ C\u0026amp;C thông qua tập tin capture.pcapng. Dựa vào những thông tin đã tìm được, dễ dàng tìm thấy chuỗi base64 chứa flag:\nHình 15. Packet chứa chuỗi base64 thông qua trường Data\nLúc này mình đã có được chuỗi base64 cần tìm, sau đó tiến hành giải mã dữ liệu. Dưới đây là script giải mã:\nfrom base64 import b64decode from Cryptodome.Cipher import ARC4 data = open(\u0026#34;enc_jpg.txt\u0026#34;, \u0026#34;rb\u0026#34;).read() arc4_cipher = b64decode(data) arc4_key = b\u0026#34;GetProcAd\\x00\\x00\\x00\u0026#34; arc4 = ARC4.new(arc4_key) out = arc4.decrypt(arc4_cipher) open(\u0026#34;flag.jpg\u0026#34;, \u0026#34;wb\u0026#34;).write(out) Cuối cùng, mình đã tìm ra được flag: HOLACTF{Sub3t3_9@_K1R4Ri}\nHình 16. Flag sau khi giải mã\n7. Tham khảo # Mình có để 03 file .idb của 03 tập tin cho mọi người tham khảo bao gồm:\nInitializer.exe: Download laskdqu_txt_stage2.bin: Download laskdqu_txt_stage3.bin: Download ","date":"30 November 2025","externalUrl":null,"permalink":"/blog/malwareanalysis-holactf-2025/","section":"Blogs","summary":"","title":"MalwareAnalysis - HolaCTF 2025","type":"blog"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/obfuscation/","section":"Tags","summary":"","title":"Obfuscation","type":"tags"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/categories/re/","section":"Categories","summary":"","title":"RE","type":"categories"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" Lời nói đầu # Vòng loại giải Sinh Viên An Toàn Thông Tin ASEAN đã kết thúc vào ngày 15/10. Đó là ngày đáng nhớ của mình cũng như các bạn khác tham gia vào ngày hôm đó, team mình - th++ đã cố gắng giành được giải Khuyến Khích. Cảm xúc của mình lúc đó có buồn, có vui. Nhưng ít nhất mình cũng đã tận hưởng những ngày tháng cùng đám bạn tham gia SVATTT với tư cách là sinh viên năm cuối ĐH.\nBài coconut mình đã không kịp giải ra vào thời điểm đó, nhưng mình đã cố gắng giải bài này và cuối cùng mình cũng đã hoàn thành. Trước khi đi vào phần writeup, mình xin cảm ơn em @mochi753 và @EaZyQ đã hỗ trợ anh giải ra được bài đó.\nGiới thiệu # Given files: coconut.exe Category: Reversing Summary: Crackme được viết bằng c# và sử dụng kỹ thuật che giấu đi code thật (không rõ chi tiết cái technique đó), bằng việc decrypt toàn bộ các hàm bị obfuscation. Sau đó reverse lại cái Crypto đó, mình tìm được key của flag1, flag thứ 2 phụ thuộc vào stack frame để cho ra key đúng, từ đó mình tìm ra được flag còn lại. Tổng quan # Nhìn tổng quan toàn bộ các hàm của binary, dễ dàng nhận ra rằng tất cả các hàm đều bị obfuscated, ngoại trừ hàm coconut_10 là nơi lưu trữ các giá trị nhằm phục vụ cho việc deobfuscate sau khi crackme được thực thi.\ninternal class Program { // Token: 0x06000017 RID: 23 RVA: 0x00002FF4 File Offset: 0x000011F4 private static void Main(string[] args) { Coconut.coconut_10(); string text = Coconut.coconut_28(); if (Coconut.coconut_25(Coconut.coconut_15(text))) { Coconut.coconut_46(text); } } } Phần Deobfuscate sẽ giải mã toàn bộ các hàm và tiếp tục phân tích.\nDeobfuscate # Mình lấy hàm coconut_28 làm ví dụ: hàm này sử dụng để giải mã cái hàm coconut_82, nhưng do hàm coconut_82 chưa được dnSpy nhận diện là 1 hàm, nên nó sẽ nhảy tới hàm coconut_25 để decode. Để ý là có coconut_meat28 và coconut_water28 được load vào.\nHàm coconut_25:\npublic static object coconut_25(InvalidProgramException e, object[] args, Dictionary\u0026lt;uint, int\u0026gt; m, byte[] b) { int metadataToken = new StackTrace(e).GetFrame(0).GetMethod().MetadataToken; Module module = typeof(Program).Module; MethodInfo methodInfo = (MethodInfo)module.ResolveMethod(metadataToken); MethodBase methodBase = module.ResolveMethod(metadataToken); ParameterInfo[] parameters = methodInfo.GetParameters(); Type[] array = new Type[parameters.Length]; SignatureHelper localVarSigHelper = SignatureHelper.GetLocalVarSigHelper(); for (int i = 0; i \u0026lt; array.Length; i++) { array[i] = parameters[i].ParameterType; } Type declaringType = methodBase.DeclaringType; DynamicMethod dynamicMethod = new DynamicMethod(\u0026#34;\u0026#34;, methodInfo.ReturnType, array, declaringType, true); DynamicILInfo dynamicILInfo = dynamicMethod.GetDynamicILInfo(); MethodBody methodBody = methodInfo.GetMethodBody(); foreach (LocalVariableInfo localVariableInfo in methodBody.LocalVariables) { localVarSigHelper.AddArgument(localVariableInfo.LocalType); } byte[] signature = localVarSigHelper.GetSignature(); dynamicILInfo.SetLocalSignature(signature); foreach (KeyValuePair\u0026lt;uint, int\u0026gt; keyValuePair in m) { int value = keyValuePair.Value; uint key = keyValuePair.Key; int tokenFor; if (value \u0026gt;= 1879048192 \u0026amp;\u0026amp; value \u0026lt; 1879113727) { tokenFor = dynamicILInfo.GetTokenFor(module.ResolveString(value)); } else { MemberInfo memberInfo = declaringType.Module.ResolveMember(value, null, null); if (memberInfo.GetType().Name == \u0026#34;RtFieldInfo\u0026#34;) { tokenFor = dynamicILInfo.GetTokenFor(((FieldInfo)memberInfo).FieldHandle, ((TypeInfo)((FieldInfo)memberInfo).DeclaringType).TypeHandle); } else if (memberInfo.GetType().Name == \u0026#34;RuntimeType\u0026#34;) { tokenFor = dynamicILInfo.GetTokenFor(((TypeInfo)memberInfo).TypeHandle); } else if (memberInfo.Name == \u0026#34;.ctor\u0026#34; || memberInfo.Name == \u0026#34;.cctor\u0026#34;) { tokenFor = dynamicILInfo.GetTokenFor(((ConstructorInfo)memberInfo).MethodHandle, ((TypeInfo)((ConstructorInfo)memberInfo).DeclaringType).TypeHandle); } else { tokenFor = dynamicILInfo.GetTokenFor(((MethodInfo)memberInfo).MethodHandle, ((TypeInfo)((MethodInfo)memberInfo).DeclaringType).TypeHandle); } } b[(int)key] = (byte)tokenFor; b[(int)(key + 1U)] = (byte)(tokenFor \u0026gt;\u0026gt; 8); b[(int)(key + 2U)] = (byte)(tokenFor \u0026gt;\u0026gt; 16); b[(int)(key + 3U)] = (byte)(tokenFor \u0026gt;\u0026gt; 24); } dynamicILInfo.SetCode(b, methodBody.MaxStackSize); return dynamicMethod.Invoke(null, args); } MetadataToken thực hiện load token nhằm lấy data của hàm coconut_82, sau đó thực hiện vòng lặp để nạp vào các section và tiến hành giải mã các byte của hàm coconut_82, cuối cùng thực thi chúng bằng method dynamicMethod.Invoke(null, args).\nmetataToken: Hàm giải mã:\nb[(int)key] = (byte)tokenFor; b[(int)(key + 1U)] = (byte)(tokenFor \u0026gt;\u0026gt; 8); b[(int)(key + 2U)] = (byte)(tokenFor \u0026gt;\u0026gt; 16); b[(int)(key + 3U)] = (byte)(tokenFor \u0026gt;\u0026gt; 24); Nhận xét: hàm coconut_25 chỉ thực hiện giải mã bằng cách dùng toán tử shift right lần lượt là 8, 16, 24, mình có thể viết script để thực hiện giải mã:\ndef ASCIS_coconut_decrypt(meat, water): for i in range(len(meat)): water[meat[i][0]] = meat[i][1] \u0026amp; 0xff water[meat[i][0] + 1] = (meat[i][1] \u0026gt;\u0026gt; 8) \u0026amp; 0xff water[meat[i][0] + 2] = (meat[i][1] \u0026gt;\u0026gt; 16) \u0026amp; 0xff water[meat[i][0] + 3] = (meat[i][1] \u0026gt;\u0026gt; 24) \u0026amp; 0xff return water Sau đó sửa các byte dựa trên địa chỉ của water tương ứng với hàm cần giải mã, trong trường hợp ở đây là water28 có địa chỉ là 0x7bc + 21 với 21 là size của water28.\nNOTE: để tìm chính xác địa chỉ của water28, mình sử dụng chức năng Show Instructions in Hex Editor.\nFull script mình để ở đây: deobfuscate_coconut\nPhân tích coconut.exe (patched) # Sau khi decrypt xong, hàm coconut_82 và các hàm khác đã được giải mã.\nNhập key và read key. public static string coconut_82() { Console.Write(\u0026#34;Enter key: \u0026#34;); return Console.ReadLine(); } Hàm xử lý input public static string coconut_51(string s) { return BitConverter.ToString(Encoding.Default.GetBytes(s)).Replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;); } Quan sát hàm coconut_51, mình nhận thấy nó thực hiện 2 bước để check. Đầu tiên chúng sẽ convert các ký tự ASCII sang chuỗi số thập lục phân và xoá các ký tự - để thành 1 chuỗi hexstring. Tiếp tục đi vào hàm coconut_52 để thực hiện check key.\nHàm coconut_52: public static bool coconut_52(string i) { return BigInteger.Parse(i, NumberStyles.HexNumber) * Coconut.coconut_89(Coconut.water_01) % Coconut.coconut_89(Coconut.water_02) == Coconut.coconut_89(Coconut.water_03); } public static BigInteger coconut_98(byte[] b) { string text = \u0026#34;\u0026#34;; foreach (byte b2 in b) { if (b2 \u0026lt; 10) { text += ((char)(b2 + 48)).ToString(); } else { text += ((char)(b2 + 87)).ToString(); } } return BigInteger.Parse(text, NumberStyles.HexNumber); } Quan sát hàm coconut_98, chúng sẽ load lần lượt các giá trị Coconut.water_01, Coconut.water_02, Coconut.water_03 để tính toán ra các số nguyên lớn và sau khi input được convert sang chuỗi hexstring, method BigInteger trong hàm coconut_52 prase chuỗi hexstring thành số nguyên lớn. Sau đó thực hiện tính toán để check key.\nNhận xét: Một bài toán liên quan tới Crypto, tuy nhiên thì mình không đi sâu về phần giải thích mà chỉ đưa ra phần giải.\n-- PROBLEM -- passwd * coconut_water01 % coconut_water02 = coconut_water03 =\u0026gt; passwd = (coconut_water03 * inverse(coconut_water01, coconut_water02)) % coconut_water02 Thực hiện bằng python script passwd = long_to_bytes((ASCIS_coconut_52_BIGNUMBER(coconut_water03) * inverse(ASCIS_coconut_52_BIGNUMBER(coconut_water01), ASCIS_coconut_52_BIGNUMBER(coconut_water02))) % ASCIS_coconut_52_BIGNUMBER(coconut_water02)) Chạy file script trên, mình đã tìm ra được key: Ytd_is_history_Tmr_is_a_mystery!. Lúc này mình thử test trên powershell thì ra được thông báo dưới đây:\nTuy nhiên trong lúc chạy thì file PANDA.png đã được dump ra:\nNhư vậy mình đã có được 1 phần của flag: ASCIS{7hat's_Why_7h3y_call_it. Tuy nhiên phần còn lại của flag thì mình chưa biết, vì cái thông báo trên powershell lúc nãy đã cho mình biết được nhiệm vụ tiếp theo phải bypass được đoạn đó để tìm ra flag còn lại.\nBypass the Time # Phân tích lại file sau khi đã deobfuscated, sau khi đã decrypt ra file PANDA.jpg bằng thuật toán AES, nó nhảy vào hàm coconut_06 và tới hàm coconut_60:\npublic static void coconut_60() { while (DateTime.Now.Year \u0026lt; 3022) { Console.WriteLine(\u0026#34;Waiting for a thousand year.\u0026#34;); Thread.Sleep(86400000); } Coconut.coconut_36(); } Đoạn check chỉ kiểm tra năm hiện tại trên máy tính có lớn hơn 3022 hay không, ngược lại nó sẽ nhảy vào vòng lặp \u0026ldquo;vô tận\u0026rdquo;. Để pass nó, bạn đọc có thể edit lại method và sửa dấu \u0026lt; thành \u0026gt;. Lưu lại và chạy file đã patched.\nLần này mình đã dump ra được file DRAGON_WARRIOR.png, nhưng có gì đó không đúng\u0026hellip;.\nDebug qua đoạn dump ra file DRAGON_WARRIOR.png cụ thể ở đây là hàm coconut_16, mình thấy nó in ra key: Void coconut_63()System.String coconut_16()\nPhân tích hàm coconut_61, nó đang lấy Frame dựa trên stackTrace để lấy tên hàm con thuộc coconut_61,trong trường hợp này là hàm coconut_61 và coconut_63. Cho nên mới có kết quả khi return cái key trên. Tuy nhiên, key đó không đúng vì lúc nãy mình đã chạy thử file patched trước đó.\npublic static string coconut_61() { StackTrace stackTrace = new StackTrace(); return stackTrace.GetFrame(2).GetMethod().ToString() + stackTrace.GetFrame(1).GetMethod().ToString(); } Vậy vấn đề ở đây là gì ?\nQuay trở lại hàm coconut_36, try-catch sẽ thực hiện nhảy vào hàm coconut_63, nếu như hàm đó không bị lỗi và ngược lại nó sẽ nhảy vào hàm coconut_25. Vấn đề là khi trace tới coconut_63 nó không bị lỗi bởi vì mình đã deobfuscate hàm đó rồi. Đó chính là mấu chốt của bài toán trên, vì vậy mình buộc phải trace vào hàm coconut_25 thì mới return về key đúng.\n**Giải pháp:**Chuyển số 3022 ra dạng hexadecimal ta được 0x0bce, tức là 206 và 11. Đồng thời mở file Coconut.exe ban đầu (chưa modified gì hết), ta lấy tất cả bytes của water06:\nTìm số 206 và 11, mình thấy nó nằm trong mảng water06. Pattern đó chính là số 3022 thuộc đoạn while (DateTime.Now.Year \u0026gt; 3022), mình có thể thay số 3022 thành số nào nhỏ hơn năm hiện tại trên máy (ở đây là năm 2022), ở đây mình sẽ dùng số 2019 tức là 227 07 dưới dạng bytearray. Sau đó patch 2 số đó vào vị trí của số 206 và 11.\nwater06 sau khi được modified: Cuối cùng, chạy file sau khi sửa, ta đã thành công dump được file DRAGON_WARRIOR.png:\nFlag thứ 2: _Prrrres3nt!!!!}\nGhép lại flag1 và flag2, ta được 1 flag hoàn chỉnh: ASCIS{7hat's_Why_7h3y_call_it_Prrrres3nt!!!!} Full script solve mình để ở đây: solve\nEND # Hết rồi =)))\n","date":"19 October 2022","externalUrl":null,"permalink":"/blog/coconut-ascis-ctf-2022/","section":"Blogs","summary":"","title":"Coconut - ASCIS CTF 2022","type":"blog"},{"content":"Welcome to my website! I\u0026rsquo;m really happy you stopped by.\n","date":"18 October 2022","externalUrl":null,"permalink":"/blog/my-first-post/","section":"Blogs","summary":"","title":"My first blog","type":"blog"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]